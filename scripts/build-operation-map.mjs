#!/usr/bin/env node

import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import ts from 'typescript'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..')

const sourcePath = path.resolve(projectRoot, 'src/generated/pure.ts')
const outputPath = path.resolve(projectRoot, 'src/generated/operation-map.ts')

const sourceContent = fs.readFileSync(sourcePath, 'utf8')
const sourceFile = ts.createSourceFile('pure.ts', sourceContent, ts.ScriptTarget.ESNext, true, ts.ScriptKind.TS)

const operationIds = new Set()
const operationMetadata = new Map()

for (const statement of sourceFile.statements) {
    if (!ts.isInterfaceDeclaration(statement)) {
        continue
    }

    if (statement.name.text === 'operations') {
        for (const member of statement.members) {
            if (!ts.isPropertySignature(member) || !member.name) {
                continue
            }

            if (ts.isIdentifier(member.name) || ts.isStringLiteral(member.name)) {
                operationIds.add(member.name.text)
            }
        }
        continue
    }

    if (statement.name.text !== 'paths') {
        continue
    }

    for (const member of statement.members) {
        if (!ts.isPropertySignature(member) || !member.name || !member.type) {
            continue
        }

        if (!ts.isStringLiteral(member.name)) {
            continue
        }

        if (!ts.isTypeLiteralNode(member.type)) {
            continue
        }

        const absolutePath = member.name.text
        const segments = absolutePath.split('/').filter(Boolean)
        const baseSegment = segments[0] ?? ''
        const basePath = baseSegment ? `/${baseSegment}` : '/'
        const restSegments = segments.slice(1)
        const relativePath = restSegments.length > 0 ? `/${restSegments.join('/')}` : ''

        for (const methodMember of member.type.members) {
            if (!ts.isPropertySignature(methodMember) || !methodMember.name || !methodMember.type) {
                continue
            }

            if (!ts.isIdentifier(methodMember.name)) {
                continue
            }

            const methodName = methodMember.name.text
            if (!['get', 'post', 'put', 'delete'].includes(methodName)) {
                continue
            }

            const typeNode = methodMember.type
            if (!ts.isIndexedAccessTypeNode(typeNode)) {
                continue
            }

            if (!ts.isTypeReferenceNode(typeNode.objectType)) {
                continue
            }

            const objectTypeName = typeNode.objectType.typeName
            if (!objectTypeName) {
                continue
            }

            const typeNameText = ts.isIdentifier(objectTypeName)
                ? objectTypeName.text
                : ts.isQualifiedName(objectTypeName)
                    ? objectTypeName.right.text
                    : undefined

            if (typeNameText !== 'operations') {
                continue
            }

            const indexType = typeNode.indexType
            if (!ts.isLiteralTypeNode(indexType) || !ts.isStringLiteral(indexType.literal)) {
                continue
            }

            const operationId = indexType.literal.text
            operationMetadata.set(operationId, {
                method: methodName,
                basePath,
                relativePath: relativePath || undefined
            })
        }
    }
}

const missingOperationIds = [...operationIds].filter((id) => !operationMetadata.has(id))
if (missingOperationIds.length > 0) {
    console.error('Failed to resolve metadata for operation IDs:', missingOperationIds.join(', '))
    process.exit(1)
}

const sortedOperationIds = [...operationIds].sort()

const literal = (value) => JSON.stringify(value)

const entries = sortedOperationIds
    .map((operationId) => {
        const metadata = operationMetadata.get(operationId)
        if (!metadata) {
            throw new Error(`Missing metadata for operation ${operationId}`)
        }

        const parts = [
            `method: ${literal(metadata.method)}`,
            `basePath: ${literal(metadata.basePath)}`
        ]

        if (metadata.relativePath) {
            parts.push(`path: ${literal(metadata.relativePath)}`)
        }

        return `    ${literal(operationId)}: { ${parts.join(', ')} }`
    })
    .join(',\n')

const fileContent = `// This file is auto-generated by scripts/build-operation-map.mjs. Do not edit manually.

import type { operations } from './pure'

export type OperationId = keyof operations

export type HttpMethod = 'get' | 'post' | 'put' | 'delete'

export interface OperationMetadata {
    readonly method: HttpMethod
    readonly basePath: string
    readonly path?: string
}

export const operationMetadata = {
${entries}
} as const satisfies Record<OperationId, OperationMetadata>

export function getOperationMetadata(operationId: OperationId): OperationMetadata {
    return operationMetadata[operationId]
}
`

fs.writeFileSync(outputPath, `${fileContent}\n`)
